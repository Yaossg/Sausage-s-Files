# [第二节]模板参数概述

>你需要一个模具！ ——当你在浇铸时

## 模板参数

**模板形参(template parameter)**是用于在模板内表示实参的标识符

**模板实参(template argument)**是用于在实例化模板时用的具体参数

模板形参一般分为四种：

1. **类型模板参数(type template parameter)**
2. **非类型模板参数(non-type template parameter)**
3. **模板的模板参数(template template parameter)**
4. **(C++20)约束模板参数(constrained template parameter)**

## 类型模板参数

即，以类型作为模板的参数，以关键词**typename**或**class**引导，基本语法如下 

```C++
typename|class name = default
```

其中name就是这个形参的名称，如果用不上，可以省略。

= default用于指定默认值，可选，后面详细介绍

**[提示]**关于这里使用`typename`还是`class`一直都是一个争论不休的话题

`class`属于历史遗留，存在于大量的旧代码之中，但仍然被很多人沿用至今

`typename`则是后来专门提供的一个关键字，在很多新的代码中较为常见

而且并不是所有模板参数列表中的`class`都可以替换成`typename`**(直到C++17)**

在本教程中，(只要可以)一律使用**typename** 

**[提示]**不管你是选用哪一个关键字作为引导，坚持其中一个是最为重要的 

**[提示]**不可以用`struct`或者`union`代替`class`

**[提示]**如同它的名字一样"`typename`"本质上就是引导类型的名字而已

它并不是什么数据类型(如果你疑惑于为何我要这么说，请看后面的非类型模板参数)

所以不能将它用作给类型"取别名"，所以下面这句话是错误的

```C++
typename my_type = int; //ERROR!
```

**(C++11)**如果你希望使用类似的语法，可以使用`using`

```C++
using my_type = int;
```

##非类型模板参数

非类型模板参数，即，不以类型作为模板的参数，基本语法如下

```C++
type name = default	
```

其中type就是这个模板参数的类型，它可以是一下任意一个(所有的cv限定符和修饰符都会被忽略) 

(表格右侧标注了在C++11`<type_traits>`的检查方法，其中`using T = typename std::decay<你需要检测的类型>::type`)

|类型|检测方法:当下列表达式为true时|
|------|------|
|整数类型|`std::is_integral<T>::value`|
|左值引用类型 (引用 对象 或 函数)|`std::is_lvalue_reference<T>::value`|
|指针类型 (指向 对象 或 函数)|`std::is_pointer<T>::value`|
|成员指针类型 (指向 成员对象 或 成员函数)|`std::is_member_pointer<T>::value`|
|枚举类型|`std::is_enum<T>::value`|
|std::nullptr_t **(C++11)**|`std::is_null_pointer<T>::value`|

**(C++17)**你也可是把type指定为`auto`，由编译器进行推断，但是必须是上述类型之一 

而name就是这个形参的名称，如果用不上，可以省略。

= default用于指定默认值，可选，后面详细介绍 

## 非类型模板参数的限制

对于整数类型和枚举，它的模板参数必须是**常量表达式(constant expression)** 

即在编译时就必须确定值，比如`5`, `(3 + 2) * 6`, `std::numeric_limits<int>::max()`

对于指针和引用要么使用**(C++11)**`nullptr`要么就必须"带有链接"(with a linkage)的指针或引用 

**[提示]**关于"链接"(linkage),可以查阅相关书籍教程，那不属于本教程范围

对于成员指针要么使用**(C++11)**`nullptr`要么写成&Class::Member的形式

**(C++11)**对于`nullptr_t`，能且只能是`nullptr`

**(C++17)**在C++17中，对于指针和引用的限制采用一套更加宽松的机制 

它们只要不指向/引用一下内容即可:

- 子对象 (包括非静态子对象，基类子对象，数组元素)
- 临时对象 (包括创建时初始化的引用)
- 字符串字面量 (比如`"hello"`)
- `typeid`的结果 (比如`typeid(T)`)
- 预定义变量 `__func__`.

**[提示]**如果你觉得非类型模板参数的限制有些生涩难懂，就不用去深究了，大部分情况下，记住"整数和枚举"那一部分就可以了

## 默认模板实参数

我们可以给模板指定一个默认值，即**默认模板参数(default template arguments)**，所有默认的模板参数必须位于模板参数列表的末尾

它们可以分开声明，但是对于一个参数，只能指定一次默认值，可以通过多个声明来个个指定，例如:

```C++
template<typename T, int N = 233> void f();
template<typename T = double, int N> void f();
template<typename T, int N = 233> void f();//错误：第二次指定默认值，即使默认值相同 
```

上面的例子(前两个声明)等同于：

```C++
template<typename T = double, int N = 233> void f();
```

**[提示]**不管如何，你都最好把所有默认值写在一处:要么声明处，要么定义处，请勿兵分三路 

## 模板参数的命名

不管是什么东西都有相应的命名规范，模板参数也不例外

最明显的，首字母必须大写，这甚至比类的首字母大写还要严格

不同的模板参数，也会有不同的常用名

比如类型就常常是`T`、`U`、`V` `T1`、`T2`、`T3`，整数常常是`I`、`N` 等等

也可以写成带有含义的形式，比如`CharT`、`Allocator`、`Compare`

以后我们还会遇到`Types`、`Args`、`Ints`这样的带's'的模板参数

**[提示]**好的模板参数名称能巧妙的表达这个参数的含义

## 最后啰嗦一句

当第一个模板参数T已经声明之后，随即可以立即使用，即使它就在模板参数列表里面使用，比如：

```C++
template<typename T, T N> // OK
void f() {}
```

小结：

- 模板参数分为三种:类型模板参数、非类型模板参数、模板的模板参数 
- 非类型模板参数有很多的限制，来确保这些值可以再编译时实现替换
- 默认模板参数位于模板参数末尾，每一个参数只能指定一次 
- 模板形参是一个声明就可以立即使用的名字，并且命名最好有一定规律
- 模板的声明和定义不可以分离，必须把模板的定义紧紧跟在模板声明后面
